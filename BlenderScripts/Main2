import bpy
import os
import time

# --- KONFIGURATION ------------------------------------------------
DESKTOP_PATH = os.path.join(os.path.expanduser("~"), "Desktop")
OUTPUT_FILE = os.path.join(DESKTOP_PATH, "verschattung_final_sorted.csv")

OBSTACLE_COLLECTION = "map_6.osm_buildings" 
SUN_OBJECT_NAME = "Sun"
WINDOW_KEYWORD = "IfcWindow" 

# Zeit-Einstellungen (Beispiel für Sampling)
# Tipp: Für Testzwecke erstmal Schrittweite auf 60 lassen
SIMULATION_DATES = [(21, 6), (21, 12)] 
START_HOUR = 6
END_HOUR = 20
MINUTES_STEP = 60 # Hier auf 15 stellen für die finale Rechnung!
YEAR = 2024
# ------------------------------------------------------------------

def run_final_simulation():
    start_time = time.time()
    print("=" * 60)
    print("STARTE SORTIERTE MATRIX-SIMULATION")
    print("=" * 60)

    # 1. Ressourcen
    sun = bpy.data.objects.get(SUN_OBJECT_NAME)
    depsgraph = bpy.context.evaluated_depsgraph_get()
    
    # 2. Sensoren finden und filtern
    raw_sensors = [obj for obj in bpy.context.scene.objects 
                   if WINDOW_KEYWORD in obj.name 
                   and "Style" not in obj.name 
                   and obj.type == 'MESH']
    
    # --- FIX 1: SORTIERUNG ---
    # Wir sortieren die Liste JETZT nach dem BMKZ.
    # Falls kein BMKZ da ist, nehmen wir den Namen als Fallback.
    print(f"Sortiere {len(raw_sensors)} Fenster...")
    raw_sensors.sort(key=lambda x: x.get("BMKZ", x.name))
    
    # Wir speichern die sortierte Liste. Ab jetzt ist Index 0 immer das erste Fenster (z.B. EG_01).
    sensors = raw_sensors 
    
    # --- FIX 2: SICHERE DATENSTRUKTUR ---
    # Statt Dictionary nutzen wir eine Liste von Listen.
    # results[0] ist die Datenzeile für sensors[0]
    results = [ [] for _ in sensors ]
    
    time_headers = []

    # 3. Hindernisse cachen
    obstacles = set()
    if OBSTACLE_COLLECTION in bpy.data.collections:
        for o in bpy.data.collections[OBSTACLE_COLLECTION].objects:
            obstacles.add(o.name)

    # 4. Simulation Loop
    sp = bpy.context.scene.sun_pos_properties
    sp.year = YEAR
    
    # Zeit-Iterationen berechnen
    steps_per_day = int((END_HOUR - START_HOUR) * (60 / MINUTES_STEP)) + 1
    total_steps = len(SIMULATION_DATES) * steps_per_day
    current_step = 0

    print(f"Berechne {total_steps} Zeitschritte für {len(sensors)} Fenster...")

    for day, month in SIMULATION_DATES:
        # Wir iterieren über Minuten
        for total_minutes in range(START_HOUR * 60, (END_HOUR * 60) + 1, MINUTES_STEP):
            
            # Zeit umrechnen
            hour = total_minutes // 60
            minute = total_minutes % 60
            time_val = hour + (minute / 60.0)
            
            current_step += 1
            if current_step % 5 == 0:
                print(f"Fortschritt: {current_step}/{total_steps} ({day}.{month}. {hour:02d}:{minute:02d})")

            # Spalten-Header speichern
            col_name = f"{day}.{month}._{hour:02d}:{minute:02d}"
            time_headers.append(col_name)

            # Sonne setzen
            sp.day = day
            sp.month = month
            sp.time = time_val
            bpy.context.view_layer.update()

            sun_loc = sun.matrix_world.translation
            is_night = sun_loc.z < 0 # Nacht-Check

            # --- DER RAYCAST LOOP ---
            # Wir nutzen enumerate, damit wir genau wissen, welcher Index (i) dran ist
            for i, sensor in enumerate(sensors):
                
                val_to_write = "0" # Standard: Sonne
                
                # A) Nacht-Check (Global)
                if is_night:
                    val_to_write = "0"
                    results[i].append(val_to_write)
                    continue

                # Geometrie
                start_loc = sensor.matrix_world.translation
                sun_vec = (sun_loc - start_loc)
                direction = sun_vec.normalized()
                dist = sun_vec.length

                # B) Backface Culling (Zeigt Fenster weg?)
                sensor_rot = sensor.matrix_world.to_3x3()
                # Annahme: Y ist Normale. Ggf. auf Z ändern falls Ergebnisse komisch!
                if len(sensor.data.polygons) > 0:
                    normal = sensor_rot @ sensor.data.polygons[0].normal
                    if direction.dot(normal) < -0.1:
                        val_to_write = "1" # Selbstverschattung
                        results[i].append(val_to_write)
                        continue
                
                # C) Raycast
                hit, _, _, _, hit_obj, _ = bpy.context.scene.ray_cast(
                    depsgraph,
                    start_loc + (direction * 0.1),
                    direction,
                    distance=dist
                )
                
                if hit and (hit_obj.name in obstacles):
                    val_to_write = "1" # Fremdverschattung
                
                # --- HIER IST DER FIX ---
                # Wir schreiben direkt in den Index i. Kein Key-Lookup nötig.
                results[i].append(val_to_write)

    # 5. Schreiben
    print("Schreibe sortierte CSV...")
    with open(OUTPUT_FILE, "w") as f:
        # Header
        f.write("SensorID;" + ";".join(time_headers) + "\n")
        
        # Zeilen
        for i, sensor in enumerate(sensors):
            # Name holen (BMKZ bevorzugt)
            row_name = sensor.get("BMKZ", sensor.name)
            
            # Datenzeile bauen
            row_data = results[i]
            
            # Schreiben
            f.write(f"{row_name};" + ";".join(row_data) + "\n")

    duration = time.time() - start_time
    print(f"FERTIG in {duration:.2f} Sekunden.")
    print(f"Gespeichert unter: {OUTPUT_FILE}")

run_final_simulation()